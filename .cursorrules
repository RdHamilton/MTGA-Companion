# Cursor AI Rules

This file provides guidance to Cursor AI when working with code in this repository.

## Project Overview

MTGA-Companion is a helper application and overlay system for Magic: The Gathering Arena (MTGA). The project is written in Go and aims to provide companion functionality while MTGA is running.

## Workflow and Issue Management

**IMPORTANT**: All work must be tracked through GitHub issues and the project board.

### Issue-Driven Development
1. **No Work Without Tickets**: Never implement features, fixes, or changes without a corresponding GitHub issue
2. **Issue First**: If a task doesn't have an issue, create one before starting work
3. **Link Everything**: All PRs must reference their associated issue (e.g., "Closes #42")

### Project Board Process
The project uses GitHub Projects for tracking work: https://github.com/users/RdHamilton/projects/1

**Issue Lifecycle**:
1. **Todo** - Issue is created and ready to be worked on
2. **In Progress** - Actively working on the issue (move when you start)
3. **Done** - Issue is completed and PR is merged (GitHub auto-moves when closed)

**Before Starting Work**:
- Check the project board for available issues
- Verify the issue has clear acceptance criteria
- Ensure you understand the requirements
- Move the issue to "In Progress"

**During Development**:
- Keep the issue updated with progress notes
- Reference the issue number in all commits (e.g., "#15: Implement poller")
- Update the issue if you discover new requirements or blockers

**Completing Work**:
- Ensure all acceptance criteria are met
- Create PR with "Closes #N" in description
- Issue automatically moves to "Done" when PR is merged

### Issue Priority and Phases

**Priority Levels**:
- **High**: Critical infrastructure or blocking work
- **Medium**: Core features and important improvements
- **Low**: Nice-to-have features and enhancements

**Implementation Phases**:
- **Phase 1: Foundation** - Database, migrations, core infrastructure (#18, #19)
- **Phase 2: Core Features** - Main user-facing features (#11, #15, #16, #17)
- **Phase 3: Advanced** - Polish, analytics, and advanced features (#12, #13, #14)

**Work Order**:
- Prioritize Phase 1 (Foundation) issues first - everything depends on these
- Complete database (#18) and migrations (#19) before persistent storage features
- Phase 2 features can be worked on in parallel after Phase 1 completes
- Phase 3 features require Phase 2 completion

### Database and Migrations

**Technology Stack**:
- **Database**: SQLite3
- **Migrations**: `golang-migrate/migrate` (gomigrate)

**Migration Guidelines**:
- All schema changes must use gomigrate migrations
- Never modify existing migrations after they're merged
- Always provide both up and down migrations
- Test migrations on a copy of production data
- See issue #19 for detailed migration practices

## Development Commands

### Workflow Scripts

Two helper scripts are available to streamline development and testing:

**Development Script** (`./scripts/dev.sh`)
```bash
./scripts/dev.sh           # Run all checks and build
./scripts/dev.sh fmt       # Format code
./scripts/dev.sh vet       # Run go vet
./scripts/dev.sh lint      # Run golangci-lint
./scripts/dev.sh check     # Run fmt, vet, and lint
./scripts/dev.sh build     # Build the application
```

**Testing Script** (`./scripts/test.sh`)
```bash
./scripts/test.sh                    # Run all tests with race detection
./scripts/test.sh unit               # Run unit tests
./scripts/test.sh coverage           # Run tests with coverage report
./scripts/test.sh race               # Run tests with race detection
./scripts/test.sh verbose            # Run tests with verbose output
./scripts/test.sh bench              # Run benchmarks
./scripts/test.sh specific -name TestName -pkg ./internal/mtga
```

### Initial Setup
```bash
# Initialize Go module (if not already done)
go mod init github.com/ramonehamilton/MTGA-Companion

# Download dependencies
go mod download

# Tidy up dependencies
go mod tidy
```

### Building
```bash
# Build the application
go build -o bin/mtga-companion ./cmd/mtga-companion

# Build for specific platforms
GOOS=windows GOARCH=amd64 go build -o bin/mtga-companion.exe ./cmd/mtga-companion
GOOS=darwin GOARCH=amd64 go build -o bin/mtga-companion ./cmd/mtga-companion
GOOS=linux GOARCH=amd64 go build -o bin/mtga-companion ./cmd/mtga-companion
```

### Testing
```bash
# Run all tests
go test ./...

# Run tests with coverage
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# Run tests with verbose output
go test -v ./...

# Run specific test
go test -v -run TestName ./path/to/package

# Run tests with race detection
go test -race ./...
```

### Running
```bash
# Run without building
go run ./cmd/mtga-companion

# Run with flags
go run ./cmd/mtga-companion -flag=value
```

### Code Quality
```bash
# Format code
go fmt ./...

# Run linter (requires golangci-lint)
golangci-lint run

# Vet code
go vet ./...
```

## Architecture

### Project Context
This is a companion application for MTGA, which likely requires:
- **Process monitoring**: Detecting when MTGA is running
- **Log file parsing**: Reading and interpreting MTGA log files to track game state
- **Overlay rendering**: Creating transparent overlay windows to display information
- **Data aggregation**: Tracking statistics, card collections, or game history

### Expected Structure
When implementing this project, consider organizing code into:
- **cmd/**: Application entry points
- **internal/**: Private application code
  - **mtga/**: MTGA-specific logic (log parsing, process detection)
  - **overlay/**: UI overlay implementation
  - **tracker/**: Game state tracking and statistics
- **pkg/**: Public libraries that could be reused
- **configs/**: Configuration files and schemas

### Platform Considerations
MTGA runs on both macOS and Windows. This application should:
- Maintain cross-platform compatibility for both Mac and PC
- Use platform-agnostic libraries where possible
- Implement platform-specific code only when necessary, using build tags
- Consider libraries like `github.com/getlantern/systray` for cross-platform system tray support

### Log Reader Architecture

The log reader is organized to parse different sections of MTGA data:

**Core Components** (`internal/mtga/logreader/`)
- `path.go` - Platform-aware log file location detection
- `reader.go` - Base JSON log entry parser

**Data Section Parsers**
Each data section has its own parser module:
- **Profile** - Player profile information
- **Arena Stats** - Game statistics and performance metrics
- **Win Rate** - Win/loss tracking and calculations
- **Draft History** - Draft picks and recommendations
- **Vault Progress** - Vault opening progress tracking

**Parser Design Pattern**
- Each parser should implement a consistent interface
- Parsers extract specific JSON event types from the log
- Follow single responsibility principle - one parser per data section
- All parsers must have comprehensive test coverage
- Use composition to build complex data from log entries

## Coding Principles

### KISS (Keep It Simple, Stupid)
- Favor simple, straightforward solutions over clever or complex ones
- Avoid premature optimization and unnecessary abstractions
- Write code that is easy to understand and maintain
- Prefer clarity over brevity when they conflict

### Effective Go Standards
Follow the guidelines from https://go.dev/doc/effective_go:

**Naming**
- Use `MixedCaps` for exported identifiers, not underscores
- Keep package names lowercase, concise, single-word
- Use `-er` suffix for single-method interfaces (e.g., `Reader`, `Writer`)

**Formatting**
- Always run `gofmt` - trust the automated formatter
- Use tabs for indentation (gofmt default)
- Opening brace must be on the same line as control statements

**Error Handling**
- Return errors as additional return values, don't panic
- Check errors explicitly and handle them appropriately
- Use early returns to avoid deep nesting

**Concurrency**
- "Do not communicate by sharing memory; instead, share memory by communicating"
- Use channels to coordinate goroutines
- Prefer channels over mutex-protected shared variables

**Data Structures**
- Design types so their zero values are useful without initialization
- Use `make()` for slices, maps, and channels
- Embed types within structs for composition

**Interfaces**
- Keep interfaces small and focused
- Define interfaces where they're used, not where they're implemented
- Accept interfaces, return concrete types when appropriate

**Documentation**
- Write doc comments immediately preceding declarations
- Start comments with the name of the thing being described
- Keep comments clear and concise
